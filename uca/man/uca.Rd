% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/uca.R
\name{uca}
\alias{uca}
\title{Unique Component Analysis}
\usage{
uca(
  A,
  B,
  nv = 2,
  method = "data",
  center = FALSE,
  scale = FALSE,
  algo = "cd",
  ...
)
}
\arguments{
\item{A}{Target Data or Covariance Matrix}

\item{B}{list of background data or covariance matrices.}

\item{nv}{number of uca components to estimate}

\item{method}{method used to calculate the uca values and vectors.
Use method = 'data' when passing a n x p data matrix. Recommended when p > n
Use method = 'cov' when passing in a covariance matrix.}

\item{center}{logical: default FALSE. If TRUE, data matrix A & B are centered}

\item{scale}{logical: default FALSE. If TRUE, data matrix A & B are centered
and scaled, regardless of whether `center == TRUE` or `center == FALSE`}

\item{algo}{algorithm to find lagrange multiplier(s). valid algorithms are
"bisection", "cd" (coordinate descent), and "gd" (gradient descent). For
single background data, "cd" and "gd" are the same. default is "cd", but
bisection exists for backwards compatibility.}
}
\value{
list of three elements:
\itemize{
 \item values (eigenvalues)
 \item vectors (eigenvectors) of unique component analysis
 \item tau optimal Lagrange Multiplier(s) associated with uca
 }
}
\description{
`uca` performs unique component analysis on a given target numeric data or
covariance matrix `A`, for a set of background data(s) or covariance 
matrix(s) B. `uca` returns a list with the eigenvalues, eigenvectors, and 
optimal contrastive parameter(s).
}
\details{
For a single background, the unique component analysis (UCA) model is

\deqn{max_{v} v'(A - \lambda B)v \qquad \text{such that} (v'Bv) / (v'v) = 1}

Where p x `nv` matrix v maximizes the above for a p x p target covariance
matrix `A` and a p x p background covariance matrix `B`, where \eqn{\lambda}
satisfies \eqn{(v' B v) / (v' v) = 1}.

To run UCA with a single background, `B` should be a matrix or a list of one
element. By default, uca assumes p >> n, therefore A and B are n_{a} x p and
n_{b} x p data matrices, respectively. Specify `method = "cov"` if A and B
 are both p x p covariance matrices.

For k backgrounds, the UCA model is:

\deqn{max_{v} v'(A - \sum_{j=1}^{k}{\lambda_j B_j})v \qquad \text{such that}
 (v' B_j v) / (v' v) = 1, \qquad \text{for } j in 1:k}


To run UCA with a k background data, `B` should be a list of k elements,
with matrices \eqn{B_1} as `B[[1]]`, ..., and \eqn{B_k} as `B[[k]]`.
By default, uca assumes p >> n, therefore \eqn{A, B_1,\ldots, B_k} are 
\eqn{n_{a} x p, n_{b1} x p, \ldots, n_{bk} x p} data matrices, respectively. 
Specify `method = "cov"` if \eqn{A, B_1, \ldots, B_k} are all p x p 
covariance matrices.

The fit is done by finding \eqn{\lambda}( \eqn{\lambda_j}'s) and v which
maximize the Lagrangian. This can be done with bisection, coordinate 
descent, or gradient descent, which can be specified by setting
`algo = "bisection"`, `algo = "cd"`, and `algo = "gd"` respectively.
Coordinate descent and gradient descent are implemented using the L-BFGS-B
algorithm in `optim`.

method = "data" circumvents computing the covariance matrices by using QR
and SVD on a product of matrices. see and Tu et al. and Golub et al. for
additional detail.
}
\note{
gradient descent for multi-background uca is not yet implemented.
}
\examples{
# UCA, single background, with data matrices
x <- matrix(rnorm(150), 30, 5)
y <- matrix(rnorm(250), 50, 5)
res_data1 <- uca(x, y, method = "data")


# UCA, single background, with covariance matrices, using bisection
A <- matrix(rnorm(25), 5, 5)
B <- matrix(rnorm(25), 5, 5)
res_cov1 <- uca(A = A, B = B, method = "cov", algo = "bisection")


# UCA, multiple backgrounds, with data matrices, scaling everything
x <- matrix(rnorm(150), 30, 5)
y1 <- matrix(rnorm(250), 50, 5)
y2 <- matrix(rnorm(250), 50, 5)
res_data2 <- uca(x, list(y1, y2), method = "data", scale = T)


# UCA, multiple backgrounds, with covariance matrices, using gradient desc.
A <- matrix(rnorm(25), 5, 5)
B1 <- matrix(rnorm(25), 5, 5)
B2 <- matrix(rnorm(25), 5, 5)
res_cov2 <- uca(A = A, B = list(B1, B2), method = "cov", algo = "gd")


}
